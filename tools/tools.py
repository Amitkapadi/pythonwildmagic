import xml.dom.minidom
import multiprocessing
import subprocess
import threading
import time
import os


class Master(threading.Thread):
    """Master thread that manages processes."""

    def __init__(self, num_procs, tasks, worker_class):
        """Initialize a master thread.

        Arguments:
        
        num_procs     -  number of simultaneous processes to run
        tasks         -  list of tasks to do, each being an argument
                         to a worker process
        worker_class  -  class implementing the worker process  
        """
        
        super(Master, self).__init__()

        # List of tasks to do, and a "next" pointer
        # into that list.
        self.tasks = tasks 
        self.next = 0
        
        self.worker_class = worker_class

        # Table of (task --> ParserProcess) containing the current worker
        # processes, indexed by the unique tasks they are working on.
        self.workers = {}

        # Start up the initial parser processes.
        for ii in range(num_procs):
            self.startNext()

    def startNext(self):
        """Create and run a worker process for the next 
        task in line."""
        if self.next < len(self.tasks):
            task = self.tasks[self.next]
            self.next += 1
            worker = self.worker_class(task)
            self.workers[task] = worker
            worker.start()

    def checkWorker(self, worker):
        """Check the worker process when it is finished.

        This method is called after the worker process
        stops it's work (is no longer alive.) Override this 
        method in the subclass if needed. The parent class
        implementation is a null operation."""
        pass

    def run(self):
        """Maintain a list of The main 'run' routine."""
        num_finished = 0
        while num_finished < len(self.tasks):

            for task, worker in self.workers.items():
                
                #print 'Checking', task

                # Skip busy workers.
                if worker.is_alive():
                    continue
                
                # The worker is done. Check out the worker
                # before it leaves the workplace.
                self.checkWorker(worker)

                # Increment running count.
                num_finished += 1
                print '%d/%d'%(num_finished, len(self.tasks))

                # Remove this parser from the workers list.
                del self.workers[task]

                # Start the next parser.
                self.startNext()

            # Sleep before checking the workers list again.
            time.sleep(.100)


class ParserProcess(multiprocessing.Process):
    """Worker process that parses a file generated by GCC-XML."""

    def __init__(self, fname):
        super(ParserProcess, self).__init__()
        self.fname = fname

        # Queue to communicate with master thread.
        self.queue = multiprocessing.Queue()

    def run(self):
        """Parse the XML file looking for fully demangled class
        names, and communicate the result."""
        result = []
        doc = xml.dom.minidom.parse(self.fname)
        classes = doc.getElementsByTagName('Class')
        for entry in classes:
            name = entry.getAttribute('demangled')
            NSPACE = 'Wm5::'
            if name[:len(NSPACE)] != NSPACE:
                continue
            result.append(name)
        self.queue.put(result)


class ParserMaster(Master):
    """Master thread that manages multiprocess XML parsing runs."""

    def __init__(self, num_procs, fnames):
        """
        Arguments:

        num_procs  -  number of simultaneous parser processes to run 
        fnames     -  list of XML files to parse
        """
        super(ParserMaster, self).__init__(num_procs, fnames, ParserProcess)
        self.result = {}  # Resulting set of class names.

    def checkWorker(self, parser):
        # Add parsed names to grand total.
        for name in parser.queue.get():
            self.result[name] = None


class CommandProcess(multiprocessing.Process):
    """Worker process that simply calls a command."""

    def __init__(self, command):
        super(CommandProcess, self).__init__()
        self.command = command

    def run(self):
        subprocess.call(self.command, shell=True)
    

class GCCXMLMaster(Master):
    """Master thread that manages multiprocess runs 
    of GCC-XML (GCC preprocessor and XML generator) command."""

    def __init__(self, num_procs, in_dir, out_dir):
        """
        Arguments:
          
        num_procs  -  number of simultaneous GCC-XML commands to run
        in_dir     -  directory containing input header files
        out_dir    -  output directory for resulting XML files
        """

        # Assemble a list of GCC-XML command strings to delegate to worker processes
        commands = []
        for entry in sorted(os.listdir(in_dir)):
            pos = entry.rfind('.')
            if pos == -1:
                continue
            suffix = entry[pos:]
            if suffix != '.h':
                continue    
            # Assemble the paths.
            full = os.path.join(in_dir, entry)
            fxml = os.path.join(out_dir, entry + '.xml')
            cmd = 'gccxml %s -fxml=%s -I%s -I%s/../../LibGraphics/Renderers'%(full, fxml, in_dir, in_dir)
            commands.append(cmd)

        # Initialize the Master class using the command list.
        super(GCCXMLMaster, self).__init__(num_procs, commands, CommandProcess)

    
# The end.
