"""A set of tools used in Python Wild Magic."""

import xml.dom.minidom
import multiprocessing
import subprocess
import threading
import optparse
import time
import sys
import os


class Master(threading.Thread):
    """A master thread that manages processes."""

    def __init__(self, num_procs, tasks, worker_class):
        """
        num_procs:  number of simultaneous processes to run

        tasks:  list of tasks to do, each being an argument to a worker process

        worker_class:  class implementing the worker process
        """
        
        super(Master, self).__init__()

        # List of tasks to do, and a "next" pointer
        # into that list.
        self.tasks = tasks 
        self.next = 0
        
        self.worker_class = worker_class

        # Table of (task --> ParserProcess) containing the current worker
        # processes, indexed by the unique tasks they are working on.
        self.workers = {}

        # Start up the initial parser processes.
        for ii in range(num_procs):
            self.startNext()

        self.num_finished = 0   # Keep count of finished workers.
        self.num_succeeded = 0  # Keep count of successful tasks. 

    def startNext(self):
        """Create and run a worker process for the next 
        task in line."""
        if self.next < len(self.tasks):
            task = self.tasks[self.next]
            self.next += 1
            worker = self.worker_class(task)
            self.workers[task] = worker
            worker.start()

    def checkWorker(self, worker):
        """Check the worker process when it is finished.

        This method is called after the worker process
        stops it's work (is no longer alive.) Override this 
        method in the subclass if needed. The parent class
        implementation is a null operation."""
        pass

    def run(self):
        """The main "run" routine."""
        while self.num_finished < len(self.tasks):

            for task, worker in self.workers.items():

                # Skip busy workers.
                if worker.is_alive():
                    continue
                
                # The worker is done.
                # Increment count of finished workers.
                self.num_finished += 1

                # Increment count of successful tasks.
                if not worker.exitcode:
                    self.num_succeeded += 1

                # Check out the worker before it leaves the workplace.
                self.checkWorker(worker)

                # Remove this worker from the list of running workers.
                del self.workers[task]

                # Start the next worker.
                self.startNext()

            # Sleep before checking the workers list again.
            time.sleep(.100)


class CommandWorker(multiprocessing.Process):
    """A worker process that simply runs a command."""

    def __init__(self, command):
        """
        command:  the command to run
        """
        super(CommandWorker, self).__init__()
        self.command = command

    def run(self):
        result = subprocess.call(self.command, shell=True, 
                                 stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
        sys.exit(result)


class CommandMaster(Master):
    """A master thread that manages multiprocess runs of arbitrary commands."""

    def __init__(self, num_procs, commands):
        """
        num_procs:  number of simultaneous commands to run

        commands:  list of commands to run
        """
        # Initialize the Master class using the command list.
        super(CommandMaster, self).__init__(num_procs, commands, CommandWorker)

    def checkWorker(self, worker):

        # Report if the command erred.
        if worker.exitcode:
            print
            print 'Error running command: %s'%(worker.command,)

        # Report on progress.
        percent = float(self.num_succeeded) / len(self.tasks) * 100
        sys.stdout.write('\r' + '%d of %d (%.1f%%)'
                         %(self.num_succeeded, len(self.tasks), percent))

        # End on a newline.
        if self.num_finished == len(self.tasks):
            print            


class ParserWorker(multiprocessing.Process):
    """A worker process that parses a file generated by GCC-XML."""

    def __init__(self, fname):
        """
        fname:  name of file to parse
        """
        super(ParserWorker, self).__init__()
        self.fname = fname

        #: Queue to communicate with master thread.
        self.queue = multiprocessing.Queue()

    def run(self):
        """Parse the XML file looking for fully demangled class
        names, and communicate the result."""
        result = []
        doc = xml.dom.minidom.parse(self.fname)
        classes = doc.getElementsByTagName('Class')
        for entry in classes:
            name = entry.getAttribute('demangled')
            NSPACE = 'Wm5::'
            if name[:len(NSPACE)] != NSPACE:
                continue
            result.append(name)
        self.queue.put(result)


class ParserMaster(Master):
    """A master thread that manages multiprocess XML parsing runs."""

    def __init__(self, num_procs, fnames):
        """
        num_procs:  number of simultaneous parser processes to run 
    
        fnames:  list of XML files to parse
        """
        super(ParserMaster, self).__init__(num_procs, fnames, ParserWorker)
        self.result = {}  # Resulting set of class names.

    def checkWorker(self, parser):
        # Report on progress.
        percent = float(self.num_succeeded) / len(self.tasks) * 100
        sys.stdout.write('\r' + '%d of %d (%.1f%%)'
                         %(self.num_succeeded, len(self.tasks), percent))
        sys.stdout.flush()

        # Add parsed names to grand total.
        for name in parser.queue.get():
            self.result[name] = None
            
        # End on a newline.
        if self.num_finished == len(self.tasks):
            print

# A table of text replacements int C++ names to create legitimate Python names.
REPLACEMENTS = (
    ('<2, Wm5::Vector2<float>, Wm5::Vector2<double> >' , '2'),
    ('<3, Wm5::Vector3<float>, Wm5::Vector3<double> >' , '3'),
    ('<double, Wm5::Vector2<double> >' , '2d'),
    ('<double, Wm5::Vector3<double> >' , '3d'),
    ('<float, Wm5::Vector2<float> >'   , '2f'),
    ('<float, Wm5::Vector3<float> >'   , '3f'),
    ('<Wm5::EdgeKey, float>', 'EdgeKeyf'),
    ('<Wm5::Echar>'  , 'Echar'),
    ('<Wm5::Edouble>', 'Edouble'),
    ('<Wm5::Efloat>' , 'Efloat'),
    ('<Wm5::Eint>'   , 'Eint'),
    ('<Wm5::Elong>'  , 'Elong'),
    ('<Wm5::Ergb5>'  , 'Ergb5'),
    ('<Wm5::Ergb8>'  , 'Ergb8'),
    ('<Wm5::Eshort>' , 'Eshort'),
    ('<Wm5::Euchar>' , 'Euchar'),
    ('<Wm5::Euint>'  , 'Euint'),
    ('<Wm5::Eulong>' , 'Eulong'),
    ('<Wm5::Eushort>', 'Eushort'),
    ('<3, 3, float>', '33f'),
    ('<int, float>' , 'if'),
    ('<1, int>'   , '1i'),
    ('<1, float>' , '1f'),
    ('<2, int>'   , '2i'),
    ('<2, float>' , '2f'),
    ('<3, int>'   , '3i'),
    ('<3, float>' , '3f'),
    ('<4, int>'   , '4i'),
    ('<4, float>' , '4f'),
    ('<double>'   , 'd'),
    ('<float>'    , 'f'),
    ('<int>'      , 'i'),
    ('<2>' , '2'),
    ('<3>' , '3'),
    ('<4>' , '4'),
    ('<5>' , '5'),
    ('<6>' , '6'),
    ('Pointer0<Wm5::', 'Pointer0'),
    ('Wm5::', 'wm5.'),
    ('::', '.'),
    ('>', ''),
    )


import wm5
def compare(in_file):
    """Return (cpp_names, py_names, cpp_in_py, py_in_cpp)."""
    # Read the input file of C++ names.
    fin = open(in_file)
    lines = fin.readlines()
    fin.close()

    # Assemble a lookup table that maps Python equivalent 
    # names to their original C++ names.
    py2cpp_names = {}
    for cpp_name in lines:
        cpp_name = cpp_name.strip()
        py_name = getPyName(cpp_name)
        py2cpp_names[py_name] = cpp_name

    #fout = open('cpp.names', 'w')
    #for name in sorted(py2cpp_names.keys()):
    #    fout.write('%s\n'%name)
    #fout.close()

    # Assemble a lookup table of names found in the Python module.
    py_names = {}
    for name in sorted(dir(wm5)):
        name = 'wm5.%s'%name
        # Skip names that have swigregister stuff in em.
        SREG = '_swigregister'
        if name[len(name) - len(SREG):] == SREG:
            continue
        py_names[name] = None

    #fout = open('py.names', 'w')
    #for name in sorted(py_names.keys()):
    #    fout.write('%s\n'%name)
    #fout.close()

    # Match Python equivalents (of C++) to names in Python module.
    cpp_in_py = {}
    for name in py2cpp_names.keys():
        if name in py_names:
            cpp_in_py[name] = None

    # Match names in Python module to Python equivalents (of C++).
    py_in_cpp = {}
    for name in py_names.keys():
        if name in py2cpp_names:
            py_in_cpp[name] = None

    return (py2cpp_names,
            py_names,
            cpp_in_py,
            py_in_cpp,
            )

def getPyName(cpp_name):
    """Given a C++ name, return equivalent Python name."""
    result = cpp_name
    for old,new in REPLACEMENTS:
        result = result.replace(old, new)
    return result

def parse_cmd(name, 
              arguments, 
              options=None                              
              ):
    """Parse the command line. 

       Keyword arguments:
       name      - name of the command
       arguments - a list, each element being a tuple (name, descr, [option])
                   where name is the name of the argument, descr is a humanly 
                   readable description of the argument, and option is the 
                   third optional item (can be anything, usually a boolean
                   flag, e.g. True) which indicates that this argument is 
                   a list. If present, the option stops command processing 
                   after the said argument.
       options   - a list, each element being
                      (switch, name, storage, default, descr)

       If successful:
          1) If options are given, return (ARGS, OPTS) as dictionaries.
          2) If options are not supplied, return ARGS as a dictionary.
       If failed:
          Exit with code 2 if failed.
    """

    # Compute the length of the longest argument name.
    # We'll use this to make the usage columns look nice.
    length = 0
    for arg in arguments:
        length = max(len(arg[0]), length)

    # Assemble the usage string.
    usage = ' %s '%name
    if options:
        usage += '[options] '
    for arg in arguments:
        usage += '%s'%arg[0]
        if len(arg) == 3:
            usage += '...'
        usage += ' '
    usage += '\n\nArguments:'
    for arg in arguments:
        usage += '\n  %s'%arg[0]
        for ii in range(length - len(arg[0])):
            usage += ' '
        usage += '   %s'%arg[1]

    # Create the OptionParser object.
    opt_parser = optparse.OptionParser(usage=usage)
    if options:
        for option in options:
            opt_parser.add_option(option[0], 
                                  dest    = option[1], 
                                  action  = option[2], 
                                  default = option[3], 
                                  help    = option[4])

    # Parse the command line.
    OPTS, ARGS = opt_parser.parse_args()

    # Make sure arguments were given since
    # OptionParser considers them optional.
    if len(ARGS) < len(arguments):
        opt_parser.print_help()
        sys.exit(2)
    
    # Assemble ARGS in a dictionary.
    ARGS_DICT = {}
    count = 0
    for arg in arguments:
        # If this argument had the optional third element,
        # then give it the remainder of ARGS and stop processing.
        if len(arg) == 3:
            ARGS_DICT[arg[0]] = ARGS[count:]
            break
        else:
            ARGS_DICT[arg[0]] = ARGS[count]
        count += 1
    
    # Assemble OPTS in a dictionary.
    OPTS_DICT = {}
    if options:
        for opt in options:
            name = opt[1]
            exec('value = OPTS.%s'%name)
            OPTS_DICT[name] = value

    # Return the parsed result.
    if options:
        result = (ARGS_DICT, OPTS_DICT)
    else:
        result = ARGS_DICT
    return result

# The end.
