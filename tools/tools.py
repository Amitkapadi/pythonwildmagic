"""A set of tools used in Python Wild Magic."""

import xml.dom.minidom
import multiprocessing
import subprocess
import threading
import time
import sys
import os


class Master(threading.Thread):
    """A master thread that manages processes."""

    def __init__(self, num_procs, tasks, worker_class):
        """
        num_procs:  number of simultaneous processes to run

        tasks:  list of tasks to do, each being an argument to a worker process

        worker_class:  class implementing the worker process
        """
        
        super(Master, self).__init__()

        # List of tasks to do, and a "next" pointer
        # into that list.
        self.tasks = tasks 
        self.next = 0
        
        self.worker_class = worker_class

        # Table of (task --> ParserProcess) containing the current worker
        # processes, indexed by the unique tasks they are working on.
        self.workers = {}

        # Start up the initial parser processes.
        for ii in range(num_procs):
            self.startNext()

        self.num_finished = 0   # Keep count of finished workers.
        self.num_succeeded = 0  # Keep count of successful tasks. 

    def startNext(self):
        """Create and run a worker process for the next 
        task in line."""
        if self.next < len(self.tasks):
            task = self.tasks[self.next]
            self.next += 1
            worker = self.worker_class(task)
            self.workers[task] = worker
            worker.start()

    def checkWorker(self, worker):
        """Check the worker process when it is finished.

        This method is called after the worker process
        stops it's work (is no longer alive.) Override this 
        method in the subclass if needed. The parent class
        implementation is a null operation."""
        pass

    def run(self):
        """The main "run" routine."""
        while self.num_finished < len(self.tasks):

            for task, worker in self.workers.items():

                # Skip busy workers.
                if worker.is_alive():
                    continue
                
                # The worker is done.
                # Increment count of finished workers.
                self.num_finished += 1

                # Increment count of successful tasks.
                if not worker.exitcode:
                    self.num_succeeded += 1

                # Check out the worker before it leaves the workplace.
                self.checkWorker(worker)

                # Remove this worker from the list of running workers.
                del self.workers[task]

                # Start the next worker.
                self.startNext()

            # Sleep before checking the workers list again.
            time.sleep(.100)


class CommandWorker(multiprocessing.Process):
    """A worker process that simply runs a command."""

    def __init__(self, command):
        """
        command:  the command to run
        """
        super(CommandWorker, self).__init__()
        self.command = command

    def run(self):
        result = subprocess.call(self.command, shell=True, 
                                 stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
        sys.exit(result)


class CommandMaster(Master):
    """A master thread that manages multiprocess runs of arbitrary commands."""

    def __init__(self, num_procs, commands):
        """
        num_procs:  number of simultaneous commands to run

        commands:  list of commands to run
        """
        # Initialize the Master class using the command list.
        super(CommandMaster, self).__init__(num_procs, commands, CommandWorker)

    def checkWorker(self, worker):

        # Report if the command erred.
        if worker.exitcode:
            print
            print 'Error running command: %s'%(worker.command,)

        # Report on progress.
        percent = float(self.num_succeeded) / len(self.tasks) * 100
        sys.stdout.write('\r' + '%d of %d (%.1f%%)'
                         %(self.num_succeeded, len(self.tasks), percent))

        # End on a newline.
        if self.num_finished == len(self.tasks):
            print            


class ParserWorker(multiprocessing.Process):
    """A worker process that parses a file generated by GCC-XML."""

    def __init__(self, fname):
        """
        fname:  name of file to parse
        """
        super(ParserWorker, self).__init__()
        self.fname = fname

        #: Queue to communicate with master thread.
        self.queue = multiprocessing.Queue()

    def run(self):
        """Parse the XML file looking for fully demangled class
        names, and communicate the result."""
        result = []
        doc = xml.dom.minidom.parse(self.fname)
        classes = doc.getElementsByTagName('Class')
        for entry in classes:
            name = entry.getAttribute('demangled')
            NSPACE = 'Wm5::'
            if name[:len(NSPACE)] != NSPACE:
                continue
            result.append(name)
        self.queue.put(result)


class ParserMaster(Master):
    """A master thread that manages multiprocess XML parsing runs."""

    def __init__(self, num_procs, fnames):
        """
        num_procs:  number of simultaneous parser processes to run 
    
        fnames:  list of XML files to parse
        """
        super(ParserMaster, self).__init__(num_procs, fnames, ParserWorker)
        self.result = {}  # Resulting set of class names.

    def checkWorker(self, parser):
        # Report on progress.
        percent = float(self.num_succeeded) / len(self.tasks) * 100
        sys.stdout.write('\r' + '%d of %d (%.1f%%)'
                         %(self.num_succeeded, len(self.tasks), percent))
        sys.stdout.flush()

        # Add parsed names to grand total.
        for name in parser.queue.get():
            self.result[name] = None
            
        # End on a newline.
        if self.num_finished == len(self.tasks):
            print

# A table of text replacements int C++ names to create legitimate Python names.
REPLACEMENTS = (
    ('<2, Wm5::Vector2<float>, Wm5::Vector2<double> >' , '2'),
    ('<3, Wm5::Vector3<float>, Wm5::Vector3<double> >' , '3'),
    ('<double, Wm5::Vector2<double> >' , '2d'),
    ('<double, Wm5::Vector3<double> >' , '3d'),
    ('<float, Wm5::Vector2<float> >'   , '2f'),
    ('<float, Wm5::Vector3<float> >'   , '3f'),
    ('<Wm5::EdgeKey, float>', 'EdgeKeyf'),
    ('<Wm5::Echar>'  , 'Echar'),
    ('<Wm5::Edouble>', 'Edouble'),
    ('<Wm5::Efloat>' , 'Efloat'),
    ('<Wm5::Eint>'   , 'Eint'),
    ('<Wm5::Elong>'  , 'Elong'),
    ('<Wm5::Ergb5>'  , 'Ergb5'),
    ('<Wm5::Ergb8>'  , 'Ergb8'),
    ('<Wm5::Eshort>' , 'Eshort'),
    ('<Wm5::Euchar>' , 'Euchar'),
    ('<Wm5::Euint>'  , 'Euint'),
    ('<Wm5::Eulong>' , 'Eulong'),
    ('<Wm5::Eushort>', 'Eushort'),
    ('<3, 3, float>', '33f'),
    ('<int, float>' , 'if'),
    ('<1, int>'   , '1i'),
    ('<1, float>' , '1f'),
    ('<2, int>'   , '2i'),
    ('<2, float>' , '2f'),
    ('<3, int>'   , '3i'),
    ('<3, float>' , '3f'),
    ('<4, int>'   , '4i'),
    ('<4, float>' , '4f'),
    ('<double>'   , 'd'),
    ('<float>'    , 'f'),
    ('<int>'      , 'i'),
    ('<2>' , '2'),
    ('<3>' , '3'),
    ('<4>' , '4'),
    ('<5>' , '5'),
    ('<6>' , '6'),
    ('Pointer0<Wm5::', 'Pointer0'),
    ('Wm5::', 'wm5.'),
    ('::', '.'),
    ('>', ''),
    )

def getPyName(cpp_name):
    """Given a C++ name, return equivalent Python name."""
    result = cpp_name
    for old,new in REPLACEMENTS:
        result = result.replace(old, new)
    return result

# The end.
